<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Greedy y Backtracking - Zum's CPCFI Page</title>
    <link rel="icon" type="image/png" href="../../assets/CPCFI.png">
    <link rel="stylesheet" href="../../css/style.css">

    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

    <script>
    function copyCode(button) {
        const codeBlock = button.nextElementSibling.querySelector('code');
        navigator.clipboard.writeText(codeBlock.innerText).then(() => {
            button.innerText = "Copiado!";
            setTimeout(() => button.innerText = "Copiar c√≥digo", 2000);
        });
    }
    </script>

    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
    <button class="toggle-btn" onclick="toggleSidebar()">‚ò∞</button>
    <img src="../../assets/CPCFI og.png" alt="CPCFI Logo" class="logo">

    <div class="sidebar" id="sidebar">
        <h2>Menu</h2>
        <div class="card-header">
            <img src="../../assets/Globo.png" style="width: 15px; height:30px" alt="CPCFI Logo" class="sidebar-logo">
            <a href="../../index.html">Inicio</a>
        </div>
        <div class="card-header">
            <img src="../../assets/Globo.png" style="width: 15px; height:30px" alt="CPCFI Logo" class="sidebar-logo">
            <a href="../../pages/clases.html">Clases</a>
        </div>
        <div class="card-header">
            <img src="../../assets/Globo.png" style="width: 15px; height:30px" alt="CPCFI Logo" class="sidebar-logo">
            <a href="../../pages/recursos.html">Recursos</a>
        </div>
        <div class="card-header">
            <img src="../../assets/Globo.png" style="width: 15px; height:30px" alt="CPCFI Logo" class="sidebar-logo">
            <a href="../../pages/contacto.html">Contacto</a>
        </div>
    </div>

    <div class="main-content" id="main">
        <div class="card-header">
            <img src="../../assets/CPCFI.png" alt="CPCFI Logo" width="40px" class="section-logo">
            <h1>Algoritmos Greedy y Backtracking</h1>
        </div>

        <div class="unlinked-card">
            <h2>¬øQu√© son estas t√©cnicas?</h2>
            <p><strong>Greedy (Voraz)</strong> y <strong>Backtracking (Vuelta Atr√°s)</strong> son dos enfoques algor√≠tmicos fundamentales para resolver problemas de optimizaci√≥n y b√∫squeda. Aunque ambos exploran un gran n√∫mero de posibilidades, lo hacen de maneras muy diferentes.</p>
            <ul>
                <li>Un algoritmo <strong>Greedy</strong> toma decisiones localmente √≥ptimas en cada paso con la esperanza de encontrar una soluci√≥n globalmente √≥ptima. Es r√°pido pero no siempre funciona.</li>
                <li>Un algoritmo de <strong>Backtracking</strong> construye soluciones candidatas de forma incremental y abandona una opci√≥n tan pronto como determina que no puede conducir a una soluci√≥n v√°lida (poda). Es m√°s exhaustivo y, por lo general, m√°s lento.</li>
            </ul>
        </div>

        <div class="unlinked-card">
            <h2>üí∞ Algoritmos Greedy (Voraces)</h2>
            <p>La idea principal es simple: en cada paso, elige la opci√≥n que parece la mejor en ese momento sin pensar en las consecuencias futuras. Esta estrategia funciona solo si el problema posee dos propiedades clave:</p>
            <ul>
                <li><strong>Propiedad de elecci√≥n voraz:</strong> Una elecci√≥n localmente √≥ptima conduce a una soluci√≥n globalmente √≥ptima.</li>
                <li><strong>Subestructura √≥ptima:</strong> Una soluci√≥n √≥ptima al problema contiene soluciones √≥ptimas a sus subproblemas.</li>
            </ul>
            <h3>Estructura General en C++:</h3>
            <div>
                <button class="copy-btn" onclick="copyCode(this)">Copiar c√≥digo</button>
                <pre><code class="language-clike">
// Estructura general de un algoritmo Greedy
TipoSolucion algoritmoGreedy(vector<TipoDato>& candidatos) {
    TipoSolucion solucion; // Inicializa la soluci√≥n

    // Ordenar los candidatos si es necesario. Este es un paso muy com√∫n.
    sort(candidatos.begin(), candidatos.end(), criterioDeOrdenacion);

    while (!candidatos.empty() && !esSolucionCompleta(solucion)) {
        // 1. Seleccionar el mejor candidato actual
        TipoDato mejorCandidato = seleccionarMejor(candidatos);

        // 2. Verificar si es una elecci√≥n factible
        if (esFactible(solucion, mejorCandidato)) {
            // 3. A√±adir a la soluci√≥n
            agregarASolucion(solucion, mejorCandidato);
        }
        
        // Remover el candidato de la lista de pendientes
        removerCandidato(candidatos, mejorCandidato);
    }

    return solucion;
}
                </code></pre>
            </div>
            
            <h3>Ejemplo Cl√°sico: Problema de Selecci√≥n de Actividades</h3>
            <p>Dado un conjunto de actividades con un tiempo de inicio y fin, selecciona el m√°ximo n√∫mero de actividades que no se solapen. La estrategia Greedy es: <strong>ordenar las actividades por su tiempo de finalizaci√≥n</strong> y escoger siempre la siguiente actividad compatible que termine antes.</p>
            
            <h3>Implementaci√≥n en C++ (Selecci√≥n de Actividades):</h3>
            <div>
                <button class="copy-btn" onclick="copyCode(this)">Copiar c√≥digo</button>
                <pre><code class="language-clike">
#include &#60iostream>
#include &#60vector>
#include &#60algorithm>

struct Actividad {
    int inicio, fin;
};

bool compararActividades(const Actividad& a, const Actividad& b) {
    return a.fin < b.fin;
}

void seleccionarActividades(std::vector<Actividad>& acts) {
    // 1. Ordenar por tiempo de finalizaci√≥n
    std::sort(acts.begin(), acts.end(), compararActividades);

    std::cout << "Actividades seleccionadas: " << std::endl;
    
    // 2. La primera actividad siempre se selecciona
    int i = 0;
    std::cout << "(" << acts[i].inicio << ", " << acts[i].fin << ")" << std::endl;
    
    // 3. Iterar y elegir la siguiente actividad compatible
    for (int j = 1; j < acts.size(); j++) {
        if (acts[j].inicio >= acts[i].fin) {
            std::cout << "(" << acts[j].inicio << ", " << acts[j].fin << ")" << std::endl;
            i = j;
        }
    }
}
                </code></pre>
            </div>
        </div>
        
        <div class="unlinked-card">
            <h2>üö® ¬øCu√°ndo falla un algoritmo Greedy?</h2>
            <p>Greedy es poderoso pero no infalible. Un ejemplo cl√°sico es el <strong>Problema del Cambio de Monedas</strong>. Si tienes monedas de {1, 5, 10} para dar 15 de cambio, el enfoque Greedy (tomar siempre la moneda m√°s grande) funciona (10 + 5). Pero si las monedas son {1, 7, 10} y quieres dar 14, Greedy elegir√≠a 10 + 1 + 1 + 1 + 1. La soluci√≥n √≥ptima es 7 + 7.</p>
        </div>


        <div class="unlinked-card">
            <h2>‚Ü© Algoritmos de Backtracking</h2>
            <p>Backtracking explora sistem√°ticamente todas las posibles soluciones a un problema. Se puede visualizar como un recorrido en profundidad (DFS) de un <strong>√°rbol de espacio de estados</strong>. La clave es la <strong>poda</strong>: si una ruta parcial no puede llevar a una soluci√≥n, se abandona (se "vuelve atr√°s") y se prueba otra.</p>
            <ul>
                <li>Se usa para problemas de decisi√≥n, optimizaci√≥n y enumeraci√≥n.</li>
                <li>Garantiza encontrar una soluci√≥n si existe, pero puede ser lento.</li>
                <li>La clave es definir el <strong>estado</strong>, las <strong>decisiones</strong> y las <strong>restricciones</strong>.</li>
            </ul>
            <h3>Estructura General en C++ (Recursiva):</h3>
            <div>
                <button class="copy-btn" onclick="copyCode(this)">Copiar c√≥digo</button>
                <pre><code class="language-clike">
void backtrack(Estado& estado, vector<Decision>& decisiones, Solucion& resultado) {
    // Condici√≥n base: si el estado actual es una soluci√≥n v√°lida
    if (esSolucion(estado)) {
        procesarSolucion(resultado, estado);
        return; // A veces se detiene aqu√≠, a veces sigue buscando m√°s soluciones
    }

    // Iterar sobre todas las posibles decisiones desde el estado actual
    for (Decision decision : generarDecisiones(estado)) {
        // 1. Aplicar la decisi√≥n
        aplicar(estado, decision);

        // 2. Poda: verificar si la nueva ruta es prometedora
        if (esValido(estado)) {
            // 3. Llamada recursiva
            backtrack(estado, decisiones, resultado);
        }
        
        // 4. Deshacer la decisi√≥n (el "backtrack")
        deshacer(estado, decision);
    }
}
                </code></pre>
            </div>
            
            <h3>Ejemplo Cl√°sico: Problema de las N-Reinas</h3>
            <p>El objetivo es colocar N reinas en un tablero de N√óN de manera que ninguna reina amenace a otra. Backtracking explora colocando una reina por fila, y si una colocaci√≥n lleva a un conflicto, "vuelve atr√°s" y prueba la siguiente columna en la fila anterior.</p>
            
            <h3>Implementaci√≥n en C++ (N-Reinas):</h3>
            <div>
                <button class="copy-btn" onclick="copyCode(this)">Copiar c√≥digo</button>
                <pre><code class="language-clike">
#include &#60iostream>
#include &#60vector>

bool esSeguro(int fila, int col, int n, const std::vector<std::string>& tablero) {
    // Comprobar columna hacia arriba
    for (int i = 0; i < fila; ++i) {
        if (tablero[i][col] == 'Q') return false;
    }
    // Comprobar diagonal superior izquierda
    for (int i = fila, j = col; i >= 0 && j >= 0; --i, --j) {
        if (tablero[i][j] == 'Q') return false;
    }
    // Comprobar diagonal superior derecha
    for (int i = fila, j = col; i >= 0 && j < n; --i, ++j) {
        if (tablero[i][j] == 'Q') return false;
    }
    return true;
}

void resolverNReinas(int fila, int n, std::vector<std::string>& tablero, std::vector<std::vector<std::string>>& soluciones) {
    if (fila == n) {
        soluciones.push_back(tablero);
        return;
    }

    for (int col = 0; col < n; ++col) {
        if (esSeguro(fila, col, n, tablero)) {
            tablero[fila][col] = 'Q';     // Tomar decisi√≥n
            resolverNReinas(fila + 1, n, tablero, soluciones); // Recursi√≥n
            tablero[fila][col] = '.';     // Backtrack
        }
    }
}
                </code></pre>
            </div>
        </div>

        <div class="unlinked-card">
            <h2>Comparaci√≥n: Greedy vs. Backtracking</h2>
            <ul>
                <li><strong>Decisi√≥n:</strong> Greedy toma una decisi√≥n y nunca la reconsidera. Backtracking prueba todas las opciones y las deshace si no funcionan.</li>
                <li><strong>Optimalidad:</strong> Greedy no siempre garantiza la soluci√≥n √≥ptima; Backtracking puede encontrar todas las soluciones √≥ptimas (si se le deja explorar todo el espacio).</li>
                <li><strong>Velocidad:</strong> Greedy es mucho m√°s r√°pido, a menudo con complejidades como $O(N \log N)$ (por el ordenamiento) o $O(N)$. Backtracking puede tener complejidades exponenciales, como $O(2^N)$ o $O(N!)$, en el peor de los casos.</li>
            </ul>
        </div>
        
        <div class="unlinked-card">
            <div class="card-header">
                <img src="../../assets/CPCFI.png" alt="CPCFI Logo" width="30px" class="section-logo">
                <h1>Ejercicios:</h1>
            </div>
            
            <div class="card-header">
                <img src="../../assets/LeetCode_logo_black.png" alt="Leetcode Logo" width="20px" class="section-logo">
                <a href="https://leetcode.com/problems/non-overlapping-intervals/description/" target="_blank" style="color: aliceblue;">Greedy: 435. Non-overlapping Intervals</a>
            </div>
            
            <div class="card-header" style="margin-top: 15px;">
                <img src="../../assets/codeforces.png" alt="Codeforces Logo" width="20px" class="section-logo">
                <a href="https://codeforces.com/problemset/problem/158/A" target="_blank" style="color: aliceblue;">Greedy: 158A - Next Round</a>
            </div>

            <div class="card-header" style="margin-top: 15px;">
                <img src="../../assets/LeetCode_logo_black.png" alt="Leetcode Logo" width="20px" class="section-logo">
                <a href="https://leetcode.com/problems/permutations/" target="_blank" style="color: aliceblue;">Backtracking: 46. Permutations</a>
            </div>

            <div class="card-header" style="margin-top: 15px;">
                <img src="../../assets/LeetCode_logo_black.png" alt="Leetcode Logo" width="20px" class="section-logo">
                <a href="https://leetcode.com/problems/sudoku-solver/" target="_blank" style="color: aliceblue;">Backtracking: 37. Sudoku Solver</a>
            </div>
        </div>

        <div class="footer">
            <p>&copy; 2025 Zum's CPCFI Page. Todos los derechos reservados.</p>
        </div>
    </div>

    <script>
        const sidebar = document.getElementById("sidebar");
        const main = document.getElementById("main");

        if (localStorage.getItem("sidebarOpen") === "true") {
            sidebar.classList.add("active");
            main.classList.add("active");
        }

        function toggleSidebar() {
            sidebar.classList.toggle("active");
            main.classList.toggle("active");
            localStorage.setItem("sidebarOpen", sidebar.classList.contains("active"));
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-clike.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-cpp.min.js"></script>
    <script>
      Prism.highlightAll();
    </script>
</body>
</html>